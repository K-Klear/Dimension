local lights = {}
local no_colour = vmath.vector4(0)

local STATE_STAND = hash("stand")
local STATE_RUN_LEFT = hash("run_left")
local STATE_RUN_RIGHT = hash("run_right")
local STATE_RUN = hash("run")
local STATE_JUMP = hash("jump")
local STATE_JUMP_START = hash("jump_start")
local STATE_TURN = hash("turn")
local state = STATE_STAND
local facing = 1
local current_position
local reset_state
local state_timer

local collision_vector_x = vmath.vector3(32, 0, 0)
local collision_vector_y = vmath.vector3(0, 32, 0)

local movement_vector = vmath.vector3(0, 0, 0)

local INPUT = {}

function init(self)
	msg.post(".", "acquire_input_focus")
end

local state_reset_fn = {}
function state_reset_fn.run()
	current_position.x = math.ceil((current_position.x - 16) / 32) * 32
	go.cancel_animations(".", "position.x")
	go.set(".", "position.x", current_position.x)
	state = STATE_STAND
end
function state_reset_fn.run_turn_right()
	current_position.x = math.ceil((current_position.x - 16) / 32) * 32
	go.cancel_animations(".", "position.x")
	go.set(".", "position.x", current_position.x)
	sprite.play_flipbook("#sprite", "run_right")
	state = STATE_STAND
end
function state_reset_fn.run_turn_left()
	current_position.x = math.ceil((current_position.x - 16) / 32) * 32
	go.cancel_animations(".", "position.x")
	go.set(".", "position.x", current_position.x)
	sprite.play_flipbook("#sprite", "run_left")
	state = STATE_STAND
end
function state_reset_fn.turn()
	state = STATE_STAND
end
function state_reset_fn.walk()

end
function state_reset_fn.walk()

end



local function set_state_timer(duration, fn)
	if state_timer then
		timer.cancel(state_timer)
	end
	state_timer = timer.delay(duration, false, state_reset_fn[fn])
end

local function update_lights()
	if #lights > 2 then
		local pos = go.get_world_position()
		table.sort(lights, function(a, b) return vmath.length_sqr(pos - a.pos) < vmath.length_sqr(pos - b.pos) end)
	end
	local light_dir = vmath.vector4()
	if lights[1] then
		go.set("#sprite", "light_col_1", lights[1].colour)
		light_dir.x = lights[1].pos.x
		light_dir.y = lights[1].pos.y
		if lights[2] then
			go.set("#sprite", "light_col_2", lights[2].colour)
			light_dir.z = lights[2].pos.x
			light_dir.w = lights[2].pos.y
		end
	else
		go.set("#sprite", "light_col_1", no_colour)
	end
	go.set("#sprite", "light_direction", light_dir)
	current_position = go.get_world_position(".")
	if not physics.raycast(current_position, current_position - collision_vector_y, {hash("ground")}) then
		current_position.y = current_position.y - 2
		go.set(".", "position.y", current_position.y)
	end
end

function update(self, dt)
	if state == STATE_STAND then
		if INPUT[hash("key_right")] then
			if facing < 0 then
				if movement_vector.x == 0 then
					facing = 1
					sprite.play_flipbook("#sprite", "turn_right")
					state = STATE_TURN
					set_state_timer(0.5, "turn")
					movement_vector.x = 0
				elseif movement_vector.x == -1 then
					facing = 1
					state = STATE_TURN
					sprite.play_flipbook("#sprite", "turn_right")
					set_state_timer(0.5, "turn")
					movement_vector.x = 0
				elseif movement_vector.x == -2 then
					if physics.raycast(current_position, current_position - collision_vector_x, {hash("ground")}) then
						sprite.play_flipbook("#sprite", "stand")
						movement_vector.x = 0
					else
						go.animate(".", "position.x", go.PLAYBACK_ONCE_FORWARD, current_position.x - 32, go.EASING_LINEAR, 1/6)
						set_state_timer(0.5, "run_turn_right")
						facing = 1
						movement_vector.x = 1
						state = STATE_RUN
						sprite.play_flipbook("#sprite", "turn_right")
					end
				end
			elseif physics.raycast(current_position, current_position + collision_vector_x, {hash("ground")}) then
				sprite.play_flipbook("#sprite", "stand")
				movement_vector.x = 0
			elseif movement_vector.x == 0 then
				movement_vector.x = 1
				facing = 1
				state = STATE_RUN
				sprite.play_flipbook("#sprite", "run_right")
				go.animate(".", "position.x", go.PLAYBACK_ONCE_FORWARD, current_position.x + 32, go.EASING_LINEAR, 1/4)
				set_state_timer(1/4, "run")
			elseif movement_vector.x == 1 then
				movement_vector.x = 2
				state = STATE_RUN
				go.animate(".", "position.x", go.PLAYBACK_ONCE_FORWARD, current_position.x + 32, go.EASING_LINEAR, 1/6)
				set_state_timer(1/6, "run")
			else
				state = STATE_RUN
				go.animate(".", "position.x", go.PLAYBACK_ONCE_FORWARD, current_position.x + 32, go.EASING_LINEAR, 1/6)
				set_state_timer(1/6, "run")
			end
		elseif INPUT[hash("key_left")] then
			if facing > 0 then
				if movement_vector.x == 0 then
					facing = -1
					sprite.play_flipbook("#sprite", "turn_left")
					state = STATE_TURN
					set_state_timer(0.5, "turn")
					movement_vector.x = 0
				elseif movement_vector.x == 1 then
					facing = -1
					state = STATE_TURN
					sprite.play_flipbook("#sprite", "turn_left")
					set_state_timer(0.5, "turn")
					movement_vector.x = 0
				elseif movement_vector.x == 2 then
					if physics.raycast(current_position, current_position + collision_vector_x, {hash("ground")}) then
						sprite.play_flipbook("#sprite", "stand")
						movement_vector.x = 0
					else
						go.animate(".", "position.x", go.PLAYBACK_ONCE_FORWARD, current_position.x + 32, go.EASING_LINEAR, 1/6)
						set_state_timer(0.5, "run_turn_left")
						facing = -1
						movement_vector.x = -1
						state = STATE_RUN
						sprite.play_flipbook("#sprite", "turn_left")
					end
				end
			elseif physics.raycast(current_position, current_position - collision_vector_x, {hash("ground")}) then
				sprite.play_flipbook("#sprite", "stand")
				movement_vector.x = 0
			elseif movement_vector.x == 0 then
				movement_vector.x = -1
				facing = -1
				state = STATE_RUN
				sprite.play_flipbook("#sprite", "run_left")
				go.animate(".", "position.x", go.PLAYBACK_ONCE_FORWARD, current_position.x - 32, go.EASING_LINEAR, 1/6)
				set_state_timer(1/6, "run")
			elseif movement_vector.x == -1 then
				movement_vector.x = -2
				state = STATE_RUN
				go.animate(".", "position.x", go.PLAYBACK_ONCE_FORWARD, current_position.x - 32, go.EASING_LINEAR, 1/6)
				set_state_timer(1/6, "run")
			else
				state = STATE_RUN
				go.animate(".", "position.x", go.PLAYBACK_ONCE_FORWARD, current_position.x - 32, go.EASING_LINEAR, 1/6)
				set_state_timer(1/6, "run")
			end
		else
			sprite.play_flipbook("#sprite", "stand")
			movement_vector.x = 0
		end
	end
	update_lights()
end

function on_message(self, message_id, message, sender)
	if message_id == hash("trigger_response") then
		local light_url = msg.url(nil, message.other_id, "light")
		if message.enter then
			local colour = go.get(light_url, "colour")
			local pos = go.get_world_position(message.other_id)
			table.insert(lights, {go = message.other_id, colour = colour, pos = pos})
		else
			for key, val in ipairs(lights) do
				if val.go == message.other_id then
					table.remove(lights, key)
					break
				end
			end
		end
	end
end

local function jump_simple()
	state = STATE_JUMP
	if facing > 0 then
		sprite.play_flipbook("#sprite", "run_right")
	else
		sprite.play_flipbook("#sprite", "run_left")
	end
	go.animate(".", "position.x", go.PLAYBACK_ONCE_FORWARD, current_position.x + 128 * facing, go.EASING_LINEAR, 1/2, 0, function() reset_state(STATE_JUMP) end)
	go.animate(".", "position.y", go.PLAYBACK_ONCE_FORWARD, current_position.y + 64, go.EASING_OUTSINE, 1/4)
end

local function jump_long()
	state = STATE_JUMP
	if facing > 0 then
		sprite.play_flipbook("#sprite", "run_right")
	else
		sprite.play_flipbook("#sprite", "run_left")
	end
	go.animate(".", "position.x", go.PLAYBACK_ONCE_FORWARD, current_position.x + 192 * facing, go.EASING_LINEAR, 3/4, 0, function() reset_state(STATE_JUMP) end)
	go.animate(".", "position.y", go.PLAYBACK_ONCE_PINGPONG, current_position.y + 96, go.EASING_OUTSINE, 3/4)
end

function reset_state(condition)
	if condition and not (state == condition) then
		return
	end
	if state == STATE_JUMP_START then
		jump_long()
	elseif state == STATE_TURN then
		state = STATE_STAND
	else
		current_position.x = math.ceil((current_position.x - 16) / 32) * 32
		go.cancel_animations(".", "position.x")
		go.set(".", "position.x", current_position.x)
		state = STATE_STAND
		timer.delay(0, false, function()
			if state == STATE_STAND then
				--sprite.play_flipbook("#sprite", "stand")
			end
		end)
	end
end

function on_input(self, action_id, action)
	if action_id then
		INPUT[action_id] = not action.released
	end

	--[[
	if action_id == hash("key_left") and facing > 0 then
		facing = -1
		state = STATE_TURN
		sprite.play_flipbook("#sprite", "turn_left")
		set_state_timer(0.5, "turn")
	end
	if action_id == hash("key_left") and state == STATE_STAND then
		if not physics.raycast(current_position, current_position - collision_vector_x, {hash("ground")}) then
			facing = -1
			state = STATE_RUN
			sprite.play_flipbook("#sprite", "run_left")
			go.animate(".", "position.x", go.PLAYBACK_ONCE_FORWARD, current_position.x - 32, go.EASING_LINEAR, 1/6)
			set_state_timer(1/6, "run")
		end
	elseif action_id == hash("key_right") and state == STATE_STAND then
		if facing < 0 then
			facing = 1
			state = STATE_TURN
			sprite.play_flipbook("#sprite", "turn_right")
			set_state_timer(0.5, "turn")
		elseif not physics.raycast(current_position, current_position + collision_vector_x, {hash("ground")}) then
			facing = 1
			state = STATE_RUN
			sprite.play_flipbook("#sprite", "run_right")
			go.animate(".", "position.x", go.PLAYBACK_ONCE_FORWARD, current_position.x + 32, go.EASING_LINEAR, 1/6)
			set_state_timer(1/6, "run")
		end
	elseif action_id == hash("key_up") and not (state == STATE_JUMP_START or state == STATE_JUMP) and false then
		if not physics.raycast(current_position, current_position + collision_vector_y, {hash("ground")}) then
			if state == STATE_STAND then
				jump_simple()
			else
				state = STATE_JUMP_START
			end
		end
	end
	--]]
end